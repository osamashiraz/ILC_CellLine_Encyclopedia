CL_Annots$`mRNA Subtypes` <- factor(CL_Annots$`mRNA Subtypes`, levels = c("Lum", "Lum/HER2", "HER2", "Basal"))
CL_Annots$`RPPA Subtypes` <- factor(CL_Annots$`RPPA Subtypes`, levels = c("Lum", "Lum/HER2", "HER2", "Basal"))
CL_Annots$`DNAm Subtypes` <- factor(CL_Annots$`DNAm Subtypes`, levels = c("Lum", "Lum/HER2", "HER2", "Basal"))
CL_Annots$Histology <- factor(CL_Annots$Histology, levels = c("ILC", "ILC-like", "NST"))
source("../1-Datasets/ICLE/RPPA/Prepare_RPPA_Data.R", chdir = T)
# Load Merged Dataframe - Log2 (EdgeR CPM)
load("../1-Datasets/ICLE/RNAseq/3_Counts/BRCA_CL_EXP_Log2CPM.Rdata")
source("../1-Datasets/ICLE/Bionano/2_Structural_Variations/Prepare_SV_Data.R", chdir = T)
source("../1-Datasets/ICLE/CytoSNP/2_GenomeStudio/Prepare_SNP_Data.R", chdir = T)
## Genome Alteration Matrix - Add in Exonic alterations, SV, fusion, CNV for CDH1
suppressWarnings(source("../1-Datasets/ICLE/WES/Prepare_SNV_Data.R", chdir = T))
source("../1-Datasets/ICLE/DNAm/Prepare_DNAm_Data.R", chdir = T)
### Generate Genomics Alteration GAM
source("./Helper_Scripts/SNV_CN_Generate_GAMs.R", chdir = T)
### Add SV/Exonic Deletions for CDH1 and CTNNA1
BRCA_CL_GAM["CDH1", c("MDAMB134VI-I", "OCUBM-I")] = "DEL" # Exonic deletion
BRCA_CL_GAM["CDH1", c("HCC2185-I", "HCC2218-I", "SKBR3-I")] = "DEL" # Large deletion
BRCA_CL_GAM["CTNNA1", "MDAMB468-I"] = "DEL" # Exonic Deletion
# TCGA
source("../1-Datasets/External/TCGA/Load_TCGA_Data.R", chdir = T)
rank01 <- function(x) (rank(x, na.last = "keep", ties.method = "average") - 1) / (sum(!is.na(x)) - 1)
scale01 <- function(v) (v + 1) / 2
build_freq_tbl_from_GAM <- function(
tumor_gam,                  # genes x tumor samples: "", "MUT", "MUT;LOH", "DEL", "AMP", "LOH", "GAIN", ...
tumor_labels,               # named vector/factor; names = colnames(tumor_gam); values like "ILC"/"NST"
genes = NULL,           # e.g., "TP53_MUT_MUT;LOH_DEL", "MYC_AMP_MUT;AMP", ...
ilc_label   = "ILC",
nst_label   = "NST",
laplace     = 0.5,
fisher_alternative = c("two.sided","greater","less"),
min_count   = 3,
allowed_classes = c("MUT","DEL","AMP","MUT;GAIN","MUT;LOH","MUT;AMP","MUT;DEL","LOH","GAIN"),
debug       = F
) {
fisher_alternative <- match.arg(fisher_alternative)
# ---- sanitize GAM & labels ----
tumor_gam <- as.matrix(tumor_gam)
# trim hidden spaces in matrix values (common cause of non-matching classes)
if (!is.numeric(tumor_gam)) {
tumor_gam[] <- trimws(tumor_gam)
}
stopifnot(all(colnames(tumor_gam) %in% names(tumor_labels)))
lbl <- factor(tumor_labels[colnames(tumor_gam)])
ilc_idx <- which(lbl == ilc_label); nst_idx <- which(lbl == nst_label)
n_ilc   <- length(ilc_idx);         n_nst   <- length(nst_idx)
if (n_ilc == 0 || n_nst == 0) stop("No samples for one or both groups in tumor_labels.")
# ---- helpers ----
clean_vec <- function(x) {
if (is.null(x)) return(character(0))
x <- as.character(x); x <- trimws(x)
x[!is.na(x) & nzchar(x)]
}
# Parse "GENE_cls1_cls2" -> long rows (gene,class); bare gene -> class="ANY"
parse_specs_long <- function(spec_vec, tag) {
spec_vec <- clean_vec(spec_vec)
if (!length(spec_vec)) return(data.frame(gene=character(), class=character(), source=character()))
out <- do.call(rbind, lapply(spec_vec, function(s) {
p <- strsplit(s, "_", fixed = TRUE)[[1]]
g <- p[1]
if (length(p) == 1) {
data.frame(gene=g, class="ANY", source=tag, stringsAsFactors=FALSE)
} else {
cls <- unique(p[-1])
data.frame(gene=g, class=cls, source=tag, stringsAsFactors=FALSE)
}
}))
out
}
ilc_long <- parse_specs_long(genes, "ILC")
nst_long <- parse_specs_long(genes, "NST")
specs_long <- rbind(ilc_long, nst_long)
if (debug) {
message(sprintf("Specs (raw long): %d rows, %d genes", nrow(specs_long), length(unique(specs_long$gene))))
if (nrow(specs_long)) print(utils::head(specs_long, 12))
}
if (!nrow(specs_long)) stop("No specs provided after cleaning.")
# keep only genes present in GAM
specs_long <- specs_long[specs_long$gene %in% rownames(tumor_gam), , drop = FALSE]
if (!nrow(specs_long)) stop("None of the specified genes are present in tumor_gam.")
# validate classes strictly against allowed set; keep ANY as-is
is_any <- specs_long$class == "ANY"
bad_cls <- !is_any & !(specs_long$class %in% allowed_classes)
if (any(bad_cls) && debug) {
message("Dropping disallowed class tokens: ",
paste(unique(specs_long$class[bad_cls]), collapse=", "))
}
specs_long <- specs_long[is_any | (!is_any & specs_long$class %in% allowed_classes), , drop=FALSE]
if (!nrow(specs_long)) stop("After validation, no (gene,class) rows remain. Check allowed_classes.")
# collapse sources to flags
src_tab <- reshape(
transform(specs_long, flag=1),
timevar = "source", idvar = c("gene","class"),
direction = "wide"
)
names(src_tab) <- sub("^flag\\.", "", names(src_tab))
if (!"ILC" %in% names(src_tab)) src_tab$ILC <- NA
if (!"NST" %in% names(src_tab)) src_tab$NST <- NA
src_tab$in_ILC_spec <- !is.na(src_tab$ILC)
src_tab$in_NST_spec <- !is.na(src_tab$NST)
src_tab <- src_tab[, c("gene","class","in_ILC_spec","in_NST_spec")]
# unique (gene,class) pairs to evaluate
pairs <- unique(src_tab[, c("gene","class")])
# count functions
count_exact <- function(vec, cl) sum(vec == cl, na.rm = TRUE)
count_any   <- function(vec)     sum(!is.na(vec) & nzchar(vec))
# build rows with counts
rows <- lapply(seq_len(nrow(pairs)), function(i) {
g <- pairs$gene[i]; cl <- pairs$class[i]
if (cl == "ANY") {
k_ilc <- count_any(tumor_gam[g, ilc_idx])
k_nst <- count_any(tumor_gam[g, nst_idx])
f_ilc <- if (n_ilc > 0) k_ilc / n_ilc else NA_real_
f_nst <- if (n_nst > 0) k_nst / n_nst else NA_real_
} else {
k_ilc <- count_exact(tumor_gam[g, ilc_idx], cl)
k_nst <- count_exact(tumor_gam[g, nst_idx], cl)
# denominators are still group totals (presence vs absence of THIS class)
f_ilc <- if (n_ilc > 0) k_ilc / n_ilc else NA_real_
f_nst <- if (n_nst > 0) k_nst / n_nst else NA_real_
}
data.frame(gene=g, class=cl,
k_ILC=k_ilc, n_ILC=n_ilc, f_ILC_raw=f_ilc,
k_NST=k_nst, n_NST=n_nst, f_NST_raw=f_nst,
stringsAsFactors=FALSE)
})
counts <- do.call(rbind, rows)
# min_count filter (≥ in either group)
keep <- pmax(counts$k_ILC, counts$k_NST) >= min_count
if (debug) {
dropped <- counts[!keep, , drop=FALSE]
if (nrow(dropped))
message("Dropping by min_count (", min_count, "): ",
paste(paste0(dropped$gene, "(", dropped$class, ")"), collapse=", "))
}
counts <- counts[keep, , drop=FALSE]
if (!nrow(counts)) {
warning("No (gene,class) rows met min_count.")
return(data.frame())
}
# Fisher + OR + smoothed freqs
smooth_freq <- function(k, n, a = laplace) (k + a) / (n + 2*a)
res <- do.call(rbind, lapply(seq_len(nrow(counts)), function(i) {
a <- counts$k_ILC[i]; b <- counts$n_ILC[i] - counts$k_ILC[i]
c <- counts$k_NST[i]; d <- counts$n_NST[i] - counts$k_NST[i]
ft_p <- ft_or <- ci_low <- ci_high <- NA_real_
if ((a+b>0) && (c+d>0)) {
ft <- tryCatch(
fisher.test(matrix(c(a,b,c,d), nrow=2, byrow=TRUE),
alternative=fisher_alternative),
error=function(e) NULL
)
if (!is.null(ft)) {
ft_p  <- unname(ft$p.value)
ft_or <- if (!is.null(ft$estimate)) unname(ft$estimate) else NA_real_
if (!is.null(ft$conf.int)) { ci_low <- ft$conf.int[1]; ci_high <- ft$conf.int[2] }
}
}
if (!is.finite(ft_or)) {
ft_or <- ((a+0.5)*(d+0.5))/((b+0.5)*(c+0.5))
}
p_ILC <- smooth_freq(counts$k_ILC[i], counts$n_ILC[i])
p_NST <- smooth_freq(counts$k_NST[i], counts$n_NST[i])
data.frame(
gene   = counts$gene[i],
class  = counts$class[i],
k_ILC  = counts$k_ILC[i], n_ILC = counts$n_ILC[i],
f_ILC_raw = counts$f_ILC_raw[i], p_ILC = p_ILC,
k_NST  = counts$k_NST[i], n_NST = counts$n_NST[i],
f_NST_raw = counts$f_NST_raw[i], p_NST = p_NST,
delta_freq = p_ILC - p_NST,
OR = ft_or, OR_low = ci_low, OR_high = ci_high,
p_value = ft_p,
log2OR = if (is.finite(ft_or) && ft_or > 0) log2(ft_or) else NA_real_,
stringsAsFactors = FALSE
)
}))
# add spec flags back
out <- merge(res, src_tab, by = c("gene","class"), all.x = TRUE)
out$in_ILC_spec[is.na(out$in_ILC_spec)] <- FALSE
out$in_NST_spec[is.na(out$in_NST_spec)] <- FALSE
# FDR & ordering
out$FDR <- p.adjust(out$p_value, method = "BH")
out <- out[order(out$FDR, -abs(out$log2OR), -abs(out$delta_freq)), ]
rownames(out) <- NULL
if (debug) {
message(sprintf("Built freq table with %d rows across %d genes",
nrow(out), length(unique(out$gene))))
}
out
}
find_diff_proteins <- function(rppa_mat, groups, contrast = "ILC - NST") {
library(limma)
stopifnot(all(colnames(rppa_mat) %in% names(groups)))
# Subset to matched samples
common_samples <- intersect(colnames(rppa_mat), names(groups))
expr <- rppa_mat[, common_samples, drop = FALSE]
g    <- factor(groups[common_samples])
# Design and fit
design  <- model.matrix(~0 + g)
colnames(design) <- levels(g)
fit     <- lmFit(expr, design)
# Contrast (ILC vs NST by default)
cont    <- makeContrasts(contrasts = contrast, levels = design)
fit2    <- contrasts.fit(fit, cont)
fit2    <- eBayes(fit2)
# Results
res <- topTable(fit2, number = Inf, sort.by = "P")
res$Protein <- rownames(res)
rownames(res) <- NULL
res
}
# rna, dna, rppa
compute_resemblance <- function(tumor_mat, tumor_samples, cell_mat, cell_samples, features, n_iter = 1000, n_feature = NULL, cor_method = "spearman"){
cell_samples <- intersect(colnames(cell_mat), cell_samples)
tumor_samples <- intersect(colnames(tumor_mat), tumor_samples)
features <- intersect(features, intersect(rownames(tumor_mat), rownames(cell_mat)))
centroid <- rowMeans(tumor_mat[features, tumor_samples])
# --- Bootstrapping across proteins ---
res <- lapply(cell_samples, function(cl) {
cors <- replicate(n_iter, {
if (!is.null(n_feature)) {
feats <- sample(features, n_feature)
} else {
feats <- features
}
stats::cor(centroid[feats], cell_mat[feats, cl], use = "complete.obs", method = cor_method)
})
data.frame(
CellLine   = cl,
BootMedian = median(cors, na.rm=TRUE),
stringsAsFactors = FALSE
)
})
out <- do.call(rbind, res)
rownames(out) = out$CellLine
return(out)
}
# cnv
compute_resemblance_cnv <- function(
tumor_cn,        # genes x tumor samples (matrix/data.frame; rownames = gene names)
cell_cn,         # genes x cell lines   (matrix/data.frame; rownames = gene names)
ga,      # data.frame with columns "genename" and "chrom"
tumor_samples,
cell_samples,
B = 1000,
method = c("pearson","spearman"),
seed = NULL,
return_distributions = FALSE
) {
method <- match.arg(method)
tumor_cn <- as.matrix(tumor_cn); cell_cn <- as.matrix(cell_cn)
cell_samples <- intersect(colnames(cell_cn), cell_samples)
tumor_samples <- intersect(colnames(tumor_cn), tumor_samples)
common_genes <- intersect(rownames(tumor_cn), intersect(rownames(cell_cn), ga$genename))
ga <- ga[ga$genename %in% common_genes, , drop = FALSE]
genes_by_chr <- split(ga$genename, ga$chrom)
chromosomes <- as.character(ga$chrom)
pools <- lapply(chromosomes, function(ch) {
gpool <- genes_by_chr[[ch]]
if (is.null(gpool)) character(0) else intersect(gpool, common_genes)
})
names(pools) <- chromosomes
n_chr <- length(chromosomes)
n_cells <- length(cell_samples)
# storage
cor_mat <- matrix(NA_real_, nrow = B, ncol = n_cells,
dimnames = list(paste0("iter", seq_len(B)), cell_samples))
selected_genes <- matrix(NA_character_, nrow = n_chr, ncol = B,
dimnames = list(chromosomes, paste0("iter", seq_len(B))))
# main bootstrap loop
for (b in seq_len(B)) {
# for each chromosome choose one gene (or NA if pool empty)
chosen <- vapply(pools, function(pool) {
if (length(pool) == 0L) NA_character_ else sample(pool, 1)
}, FUN.VALUE = character(1))
selected_genes[, b] <- chosen
# build tumor centroid vector (per-chromosome mean of chosen gene across tumor_samples)
tumor_centroid <- vapply(chosen, function(g) {
if (is.na(g)) return(NA_real_)
mean(as.numeric(tumor_cn[g, tumor_samples]), na.rm = TRUE)
}, FUN.VALUE = numeric(1))
# for each cell line extract the chosen-gene values and correlate
for (ci in seq_along(cell_samples)) {
cl <- cell_samples[ci]
cell_vals <- vapply(chosen, function(g) {
if (is.na(g)) return(NA_real_)
as.numeric(cell_cn[g, cl])
}, FUN.VALUE = numeric(1))
ok <- complete.cases(tumor_centroid, cell_vals)
if (sum(ok) >= 2) {
cor_mat[b, ci] <- cor(tumor_centroid[ok], cell_vals[ok], use = "complete.obs", method = method)
} else {
cor_mat[b, ci] <- NA_real_
}
}
}
# summaries per cell line
summary_df <- data.frame(
CellLine = cell_samples,
BootMean     = apply(cor_mat, 2, function(x) mean(x, na.rm = TRUE)),
BootMedian   = apply(cor_mat, 2, function(x) median(x, na.rm = TRUE)),
stringsAsFactors = FALSE
)
if (return_distributions) {
list(summary = summary_df, correlations = cor_mat, selected_genes = selected_genes)
} else {
return(summary_df)
}
}
# mut
compute_alteration_resemblance <- function(
mut_mat,            # genes x cell lines; entries like "", "MUT", "MUT;LOH", "DEL", "AMP", ...
ILC_specs = NULL,   # character vector like c("CDH1_MUT;LOH","PTEN_DEL","GATA3")  (gene or gene_class...)
NST_specs = NULL,   # same format for NST-associated features
freq_tbl = NULL,    # data.frame with columns: gene, class, p_ILC, p_NST
scale01 = TRUE,
min_genes_per_side = 1
) {
# --- minimal input checks ---
mut_mat <- as.matrix(mut_mat)
cell_lines <- colnames(mut_mat)
if (!is.null(freq_tbl)) {
stopifnot(all(c("gene","class","p_ILC","p_NST") %in% names(freq_tbl)))
}
# --- tiny parser for specs: "GENE_CLASS1_CLASS2" -> gene, classes (vector) ---
parse_specs <- function(specs) {
if (is.null(specs) || length(specs) == 0) {
return(data.frame(gene = character(0), alts = I(list()), stringsAsFactors = FALSE))
}
out <- lapply(specs, function(s) {
parts <- strsplit(as.character(s), "_", fixed = TRUE)[[1]]
gene  <- parts[1]
alts  <- if (length(parts) > 1) parts[-1] else NA_character_
# keep alt tokens as character vector (they may contain semicolons like "MUT;LOH")
list(gene = gene, alts = unname(alts))
})
data.frame(gene = vapply(out, `[[`, character(1), "gene"),
alts = I(lapply(out, `[[`, "alts")),
stringsAsFactors = FALSE)
}
ILC_df <- parse_specs(ILC_specs)
NST_df <- parse_specs(NST_specs)
# --- build quick lookup maps from freq_tbl ---
key <- function(g, cl) paste0(g, "||", cl)
freq_p_ILC <- freq_p_NST <- list()
if (!is.null(freq_tbl) && nrow(freq_tbl)>0) {
kk <- key(freq_tbl$gene, freq_tbl$class)
freq_p_ILC <- setNames(freq_tbl$p_ILC, kk)
freq_p_NST <- setNames(freq_tbl$p_NST, kk)
}
# --- helper: contribution for one spec row (gene + allowed classes) in one cell line ---
contribution_one <- function(gene, allowed_alts, cl, side) {
# side == "ILC": we will use p_NST as baseline (reward events uncommon in NST)
# side == "NST": we will use p_ILC as baseline (penalize events common in ILC)
if (!gene %in% rownames(mut_mat)) return(0)          # gene not present -> no contribution
val <- as.character(mut_mat[gene, cl])
if (is.na(val) || identical(val, "") ) return(0)     # no alteration in this cell -> 0
# allowed_alts NA -> treat as "any non-empty alteration" (count whatever val is)
if (all(is.na(allowed_alts))) {
kk <- key(gene, val)
p_base <- if (side == "ILC") {
if (kk %in% names(freq_p_NST)) freq_p_NST[[kk]] else 0
} else {
if (kk %in% names(freq_p_ILC)) freq_p_ILC[[kk]] else 0
}
return(1 - p_base)
} else {
# allowed classes provided -> only count if observed class matches one of them
# (matching is exact string match; e.g., "MUT;LOH" must equal val)
if (val %in% allowed_alts) {
kk <- key(gene, val)
p_base <- if (side == "ILC") {
if (kk %in% names(freq_p_NST)) freq_p_NST[[kk]] else 0
} else {
if (kk %in% names(freq_p_ILC)) freq_p_ILC[[kk]] else 0
}
return(1 - p_base)
} else {
return(0)
}
}
}
# --- compute per-cell-line components ---
out_list <- lapply(cell_lines, function(cl) {
# ILC side
if (nrow(ILC_df) > 0) {
ilc_vals <- mapply(function(g,a) contribution_one(g, a, cl, "ILC"),
ILC_df$gene, ILC_df$alts, SIMPLIFY = TRUE)
part_ilc <- mean(ilc_vals)        # average contribution per tested gene
ilc_hits <- sum(ilc_vals > 0)
} else {
part_ilc <- NA_real_; ilc_hits <- NA_integer_
}
# NST side
if (nrow(NST_df) > 0) {
nst_vals <- mapply(function(g,a) contribution_one(g, a, cl, "NST"),
NST_df$gene, NST_df$alts, SIMPLIFY = TRUE)
part_nst <- mean(nst_vals)
nst_hits <- sum(nst_vals > 0)
} else {
part_nst <- NA_real_; nst_hits <- NA_integer_
}
# enforce minimum genes per side (if too few tests, set NA)
if (nrow(ILC_df) < min_genes_per_side) { part_ilc <- NA_real_; ilc_hits <- NA_integer_ }
if (nrow(NST_df) < min_genes_per_side) { part_nst <- NA_real_; nst_hits <- NA_integer_ }
combined <- (ifelse(is.na(part_ilc), 0, part_ilc)) - (ifelse(is.na(part_nst), 0, part_nst))
data.frame(CellLine = cl,
ILC_tests = nrow(ILC_df), ILC_hits = ilc_hits, ILC_component = round(as.numeric(part_ilc), 3),
NST_tests = nrow(NST_df), NST_hits = nst_hits, NST_component = round(as.numeric(part_nst), 3),
Combined_score = round(as.numeric(combined), 3),
stringsAsFactors = FALSE)
})
out <- do.call(rbind, out_list)
rownames(out) <- out$CellLine
# --- optional 0..1 scaling across Combined_score ---
if (scale01) {
rng <- range(out$Combined_score, na.rm = TRUE)
if (is.finite(rng[1]) && diff(rng) > 0) {
out$Combined01 <- round((out$Combined_score - rng[1]) / diff(rng), 3)
} else {
out$Combined01 <- NA_real_
}
}
out
}
## SELECT PATIENT AND CELL SUBSETS
LumA_tumors_subset_df <- subset(TCGA_Annots, PAM50 %in% "LumA" & `Final Pathology` %in% c("ILC", "NST"))
ILC_tumors <- subset(LumA_tumors_subset_df,`Final Pathology` == "ILC")$Case.ID
cell_ids <- subset(CL_Annots, `mRNA Subtypes` != "Basal" | Sample %in% c("MDAMB468", "HCC1187"))$Name
## Prepare Mut data
# Simplify GAMS
BRCA_CL_GAM_Simple = BRCA_CL_GAM
for (alt in c("LOH", "GAIN")) { # exclude simple alts
BRCA_CL_GAM_Simple[BRCA_CL_GAM_Simple == alt] = ""
}
TCGA_BRCA_GAM_Simple = TCGA_BRCA_GAM
for (alt in c("LOH", "GAIN")) { # exclude simple alts
TCGA_BRCA_GAM_Simple[TCGA_BRCA_GAM_Simple == alt] = ""
}
# ILC and NST Enriched Genes
ILC_genes <- c("CDH1_MUT_MUT;LOH_MUT;DEL_DEL","PTEN_MUT_MUT;LOH_DEL","FOXA1_MUT_MUT;GAIN_MUT;AMP","TBX3_MUT_MUT;DEL_MUT;LOH","CTNNA1_MUT_MUT;LOH_MUT;DEL")
NST_genes <- c("TP53_MUT_MUT;LOH_MUT;DEL_DEL", "MYC_AMP_MUT;AMP", "GRIN2A_AMP_MUT;AMP","EFCAB1_AMP_MUT;AMP", "CSMD1_MUT_MUT;LOH_MUT;DEL",
"HLA-DRB1_MUT_MUT;LOH_MUT;DEL", "GATA3_MUT","MAP3K1_MUT_MUT;GAIN_MUT;AMP","MAP2K4_MUT_MUT;GAIN_MUT;AMP")
tcga_luminal_subset <- subset(TCGA_Annots, Case.ID %in% colnames(TCGA_BRCA_GAM_Simple) & PAM50 %in% "LumA" & `Final Pathology` %in% c("ILC", "NST"))
# write.table(as.data.frame(TCGA_BRCA_GAM_Simple[c("CDH1", "TP53", "FOXA1","TBX3", "MYC", "GATA3", "MAP3K1", "CSMD1"), tcga_luminal_subset$Case.ID]), file = "~/Downloads/tumor_gam.tsv", sep = "\t", col.names = NA)
# 1) Build tumor frequencies from GAM + labels
freq_tbl <- build_freq_tbl_from_GAM(
tumor_gam    = TCGA_BRCA_GAM_Simple[, tcga_luminal_subset$Case.ID], genes = c(ILC_genes, NST_genes),
tumor_labels = setNames(tcga_luminal_subset$`Final Pathology`, tcga_luminal_subset$Case.ID),
ilc_label    = "ILC",
nst_label    = "NST",
min_count    = 3,        # require ≥3 tumors in ILC or NST with that exact class
fisher_alternative = "two.sided", debug = T, allowed_classes = c("MUT", "MUT;LOH", "MUT;AMP", "MUT;DEL", "MUT;GAIN","AMP","DEL")
)
# MSK
source("../1-Datasets/External/MSK/Load_MSK_Data.R", chdir = T)
tumor_ids <- intersect(colnames(TCGA_BRCA_GAM_Simple), ILC_tumors)
t_alt_mat <- TCGA_BRCA_GAM_Simple[unique(freq_tbl[order(freq_tbl$p_ILC, decreasing = T),]$gene), tumor_ids]
t_alt_mat[t_alt_mat == ""] = "WT"
t_alt_mat[t_alt_mat == "MUT;LOH"] = "MUT"
t_alt_mat[t_alt_mat == "MUT;GAIN"] = "MUT"
t_alt_mat[t_alt_mat == "MUT;DEL"] = "MUT"
t_alt_mat[t_alt_mat == "MUT;AMP"] = "MUT"
t_alt_mat_numeric = t_alt_mat
t_alt_mat_numeric[t_alt_mat_numeric == "WT"] = 0
t_alt_mat_numeric[t_alt_mat_numeric == "MUT"] = 3
t_alt_mat_numeric[t_alt_mat_numeric == "AMP"] = 2
t_alt_mat_numeric[t_alt_mat_numeric == "DEL"] = 1
mode(t_alt_mat_numeric) = "numeric"
t_alt_mat_numeric
# 2) Score cell lines (frequency-centered)
mut_res <- compute_alteration_resemblance(
mut_mat  = BRCA_CL_GAM_Simple[, intersect(colnames(BRCA_CL_GAM_Simple), cell_ids)],              # genes x cell lines
ILC_specs = ILC_genes,
NST_specs = NST_genes,
freq_tbl  = freq_tbl,
scale01   = TRUE, min_genes_per_side = 1
)
mut_res[order(mut_res$Combined01),]
mut_res$CombinedRank <- rank01(mut_res$Combined_score)
mut_res
BRCA_CL_GAM_Simple[, intersect(colnames(BRCA_CL_GAM_Simple), cell_ids)]
freq_tbl
BRCA_CL_GAM_Simple[, intersect(colnames(BRCA_CL_GAM_Simple), cell_ids)]
vroom_write(BRCA_CL_GAM_Simple[, intersect(colnames(BRCA_CL_GAM_Simple), cell_ids)], file = "../5-DataSharing/Model_Scorer/BRCA_CL_GAM_sub.txt", delim = ",")
vroom_write(x = BRCA_CL_GAM_Simple[, intersect(colnames(BRCA_CL_GAM_Simple), cell_ids)], file = "../5-DataSharing/Model_Scorer/BRCA_CL_GAM_sub.txt", delim = ",")
write.table(BRCA_CL_GAM_Simple[, intersect(colnames(BRCA_CL_GAM_Simple), cell_ids)], file = "../5-DataSharing/Model_Scorer/BRCA_CL_GAM_sub.txt", sep = ",")
write.table(BRCA_CL_GAM_Simple[, intersect(colnames(BRCA_CL_GAM_Simple), cell_ids)], file = "../5-DataSharing/Model_Scorer/BRCA_CL_GAM_sub.txt", sep = ",", col.names = NA, quote = F)
write.table(BRCA_CL_GAM_Simple[, intersect(colnames(BRCA_CL_GAM_Simple), cell_ids)], file = "../5-DataSharing/Model_Scorer/BRCA_CL_GAM_sub.tsv", sep = "\t", col.names = NA, quote = F)
# Prepare RNA scoring inputs
BRCA_CL_EXP_Z = as.matrix(t(scale(t(BRCA_CL_EXP))))
TCGA_BRCA_EXP_Z = as.matrix(t(scale(t(TCGA_BRCA_Log2CPM))))
# write.table(as.data.frame(BRCA_CL_EXP_Z[intersect(rownames(BRCA_CL_EXP_Z), degs$gene),  intersect(colnames(BRCA_CL_EXP_Z), cell_ids)]), file = "~/Downloads/cl_rna.tsv", sep = "\t", col.names = NA)
# write.table(as.data.frame(TCGA_BRCA_EXP_Z[intersect(rownames(TCGA_BRCA_EXP_Z), degs$gene),  intersect(colnames(TCGA_BRCA_EXP_Z), tcga_luminal_subset$Case.ID)]), file = "~/Downloads/cl_rna.tsv", sep = "\t", col.names = NA)
load("../../1-Datasets/External/TCGA/RNA/TCGA_BRCA_DESeq_LumA_ILC_vs_NST.Rdata")
setwd("~/Documents/ICLE/2-Analysis/Helper_Scripts")
load("../../1-Datasets/External/TCGA/RNA/TCGA_BRCA_DESeq_LumA_ILC_vs_NST.Rdata")
load("../../1-Datasets/ICLE/RNAseq/BRCA_CL_DEseq2_NonBasal_ILC_vs_NST.Rdata")
write.table(BRCA_CL_GAM_Simple, file = "../5-DataSharing/Model_Scorer/BRCA_CL_GAM_sub.tsv", sep = "\t", col.names = NA, quote = F)
BRCA_CL_GAM_Simple
write.table(BRCA_CL_GAM_Simple, file = "../5-DataSharing/Model_Scorer/BRCA_CL_GAM_sub.tsv", sep = "\t", col.names = NA, quote = F)
write.table(BRCA_CL_GAM_Simple, file = "../5-DataSharing/Model_Scorer/BRCA_CL_GAM_sub.tsv", sep = "\t", col.names = NA, quote = F)
write.table(BRCA_CL_GAM_Simple[, intersect(colnames(BRCA_CL_GAM_Simple), cell_ids)], file = "../5-DataSharing/Model_Scorer/BRCA_CL_GAM_sub.tsv", sep = "\t", col.names = NA, quote = F)
setwd("~/Documents/ICLE/2-Analysis/Helper_Scripts")
write.table(BRCA_CL_GAM_Simple[, intersect(colnames(BRCA_CL_GAM_Simple), cell_ids)], file = "../../5-DataSharing/Model_Scorer/BRCA_CL_GAM_sub.tsv", sep = "\t", col.names = NA, quote = F)
write.table(BRCA_CL_GAM_Simple, file = "../../5-DataSharing/Model_Scorer/BRCA_CL_GAM_sub.tsv", sep = "\t", col.names = NA, quote = F)
write.table(TCGA_BRCA_GAM_Simple, file = "../../5-DataSharing/Model_Scorer/TCGA_CL_GAM_sub.tsv", sep = "\t", col.names = NA, quote = F)
write.table(TCGA_BRCA_Log2CPM, file = "../../5-DataSharing/Model_Scorer/TCGA_EXP.tsv", sep = "\t", col.names = NA, quote = F)
write.table(BRCA_CL_EXP, file = "../../5-DataSharing/Model_Scorer/BRCA_CL_EXP.tsv", sep = "\t", col.names = NA, quote = F)
write.table(TCGA_Annots, file = "../../5-DataSharing/Model_Scorer/TCGA_Annots.tsv", sep = "\t", col.names = NA, quote = F)
write.table(CL_Annots, file = "../../5-DataSharing/Model_Scorer/CL_Annots.tsv", sep = "\t", col.names = NA, quote = F)
load("/Users/oshah/Documents/ICLE/1-Datasets/ICLE/RNAseq/3_Counts/ICLE_EXP_CTS.Rdata")
